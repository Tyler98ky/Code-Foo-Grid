# Code-Foo-Grid
  Hi! This is my implementation of the chained grid that was a challenge for Code Foo 2017. I implemented this first by making a RandomGrid object, that randomly generated a sqaure grid, of whatever size number you feed it. For example, the RandomGrid(3) constructor builds a randomized grid with a side length of 3. This makes it very easy to make a random grid of whatever size you want. Then I implemented two more classes that had the task of finding the chains, as described in the description of the challenge, and printing them out. <br/><br/>First I created the Chain object, which contains three instance variables: an integer called sum (which keeps track of the current running sum of the numbers in the chain), a stack called numbers (which keeps track of the actual numbers in the chain), and a 2d array of booleans called visited (to keep track of all the elements that we have visited, so as not to repeat them).<br/><br/>I then created the meat of the project, the brains, the GridSolver class. This object takes 2d array of integers as a parameter, and uses this array to find all the chains inside that grid. The first method in the GridSolver class, is solve(), which begins the process of going through each and every element of the given grid by using a nested for loop. For each element, it then creates a new Chain object called currentChain, and initializes that currentChain with a new boolean [][] to keep track of that specific chain's visited numbers. The method then invokes the isChain method on each number, which will go through each number and recrsively check for all possible chains, using that number as the origin of the chain.<br/><br/> The isChain method will go through and check if the specified currentChain is adding an element that is out of bounds, then if not it will add that element to the currentChain. The isChain method will then go to check and see if that chain's sum is equal to the target number, which is the dimensions of the original grid (i.e. for 3x3 grid target= 9), in which case if it is, will then return true, denoting that the currentChain object at that point is a chain. That current chain is then added to the GridSolver's HashSet<Chain> instance variable called chainList, to keep track of all the chains found in this grid. I used a HashSet data structure to ensure no chains are repeated in the chainList. There are then two more checks made in the isChain method. It will then check if the chains sum is less than the target, and if so, will recursively call isChain on this chain, which will call the recursive method, which will go through and check every single adjacent element to the one specified by calling isChain on each one of those adjacent elements.<br/><br/> After all this is done the isChain method will finally check if the currentChain has a sum greater than the target, in which case it will pop off that last element it added to the chain, and decrease the sum by that popped numbers value, so it can continue to check for more chains. The solve() method will go through and do this for each element of the grid, and when it's done, it will print out the chainList variable, which kept track of every Chain that returned true for isChain.
